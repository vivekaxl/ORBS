























#include "config.h"

#include "bashtypes.h"
















#include "shell.h"


#include "jobs.h"






#include "shmbutil.h"















#define DEFAULT_INITIAL_ARRAY_SIZE 112

























#define LPAREN		'('






























typedef WORD_LIST *EXPFUNC __P((char *, int));


pid_t last_command_subst_pid = NO_PID;





unsigned char ifs_cmap[UCHAR_MAX + 1];











int assigning_in_environment;




WORD_LIST *subst_assign_varlist = (WORD_LIST *)NULL;





















int allow_null_glob_expansion;


int fail_glob_expansion;

























static WORD_LIST *garglist = (WORD_LIST *)NULL;





static char *expand_string_if_necessary __P((char *, int, EXPFUNC *));
























static char *extract_delimited_string __P((char *, int *, char *, char *, char *, int));


































































static WORD_LIST *expand_word_internal __P((WORD_DESC *, int, int, int *, int *));














static WORD_LIST *expand_word_list_internal __P((WORD_LIST *, int));







































































































































































































































































































































INLINE char *
sub_append_string (source, target, indx, size)
     char *source, *target;
     int *indx, *size;
{

    {
      int srclen, n;

      srclen = STRLEN (source);







      FASTCOPY (source, target + *indx, srclen);
      *indx += srclen;
      target[*indx] = '\0';


    }
  return (target);
}





























































































string_extract_double_quoted (string, sindex, stripdq)

     int *sindex, stripdq;
{


  int j, i, t;













  i = *sindex;
































































































































    i++;
  *sindex = i;





































































}





static inline char *
string_extract_single_quoted (string, sindex)
     char *string;
     int *sindex;
{
  register int i;
  size_t slen;

  DECLARE_MBSTATE;



  i = *sindex;

    ADVANCE_CHAR (string, slen, i);





  *sindex = i;
























































































































}





char *
extract_command_subst (string, sindex, xflags)
     char *string;
     int *sindex;

{

    return (extract_delimited_string (string, sindex, "$(", "(", ")", xflags|SX_COMMAND)); /*)*/





}




char *
extract_arithmetic_subst (string, sindex)
     char *string;
     int *sindex;
{

}

#if defined (PROCESS_SUBSTITUTION)



char *
extract_process_subst (string, starter, sindex)
     char *string;
     char *starter;
     int *sindex;
{

}






char *
extract_array_assignment_list (string, sindex)
     char *string;
     int *sindex;
{











}
#endif









static char *
extract_delimited_string (string, sindex, opener, alt_opener, closer, flags)
     char *string;
     int *sindex;
     char *opener, *alt_opener, *closer;

{
  int i, c, si;
  size_t slen;
  char *t, *result;
  int pass_character, nesting_level, in_comment;
  int len_closer, len_opener, len_alt_opener;
  DECLARE_MBSTATE;



  len_alt_opener = STRLEN (alt_opener);
  len_closer = STRLEN (closer);



  nesting_level = 1;
  i = *sindex;

  while (nesting_level)
    {
























































      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))
	{
	  si = i + len_alt_opener;
	  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);
	  i = si + 1;

	}



      if (STREQN (string + i, closer, len_closer))
	{



	    break;
	}




















      ADVANCE_CHAR (string, slen, i);















    }

  si = i - *sindex - len_closer + 1;



    {
      result = (char *)xmalloc (1 + si);
      strncpy (result, string + *sindex, si);
      result[si] = '\0';
    }
  *sindex = i;

  return (result);
}


























































































































































































































































































































#if defined (ARRAY_VARS)

skipsubscript (string, start, flags)
     const char *string;

{

}
#endif








skip_to_delim (string, start, delims, flags)
     char *string;

     char *delims;

{















































































































}

#if defined (READLINE)









char_is_quoted (string, eindex)
     char *string;

{






































}


unclosed_pair (string, eindex, openstr)
     char *string;

     char *openstr;
{







































}








WORD_LIST *
split_at_delims (string, slen, delims, sentinel, flags, nwp, cwp)
     char *string;

     char *delims;

     int *nwp, *cwp;
{




















































































































































}


















#endif









char *
string_list_internal (list, sep)
     WORD_LIST *list;
     char *sep;
{




  if (list == 0)
    return ((char *)NULL);



    return (savestring (list->word->word));


































}



char *
string_list (list)
     WORD_LIST *list;
{
  return (string_list_internal (list, " "));
}





char *
ifs_firstchar (lenp)
     int *lenp;
{


























}






char *
string_list_dollar_star (list)
     WORD_LIST *list;
{



































}










char *
string_list_dollar_at (list, quoted)
     WORD_LIST *list;

{





















































}





char *
string_list_pos_params (pchar, list, quoted)

     WORD_LIST *list;

{





































}

































WORD_LIST *
list_string (string, separators, quoted)
     register char *string, *separators;

{














































































































}








char *
get_word_from_string (stringp, separators, endptr)
     char **stringp, *separators, **endptr;
{




















































































}






char *
strip_trailing_ifs_whitespace (string, separators, saw_escape)
     char *string, *separators;

{








}


































































































do_assignment_internal (word, expand)
     const WORD_DESC *word;

{
  int offset, appendop, assign_list, aflags, retval;
  char *name, *value, *temp;
  SHELL_VAR *entry;




  const char *string;

  if (word == 0 || word->word == 0)
    return 0;


  string = word->word;
  offset = assignment (string, 0);
  name = savestring (string);



    {






      name[offset] = 0;		/* might need this set later */
      temp = name + offset + 1;










	value = expand_string_if_necessary (temp, 0, expand_string_assignment);

















    }




























  entry = bind_variable (name, value, aflags);

























}




do_assignment (string)
     char *string;
{






}


do_word_assignment (word, flags)
     WORD_DESC *word;

{
  return do_assignment_internal (word, 1);
}





do_assignment_no_expand (string)
     char *string;
{






}








WORD_LIST *
list_rest_of_args ()
{











}


number_of_args ()
{








}


char *
get_dollar_var_value (ind)
     intmax_t ind;
{













}

















































































static char *
expand_string_if_necessary (string, quoted, func)
     char *string;

     EXPFUNC *func;
{
  WORD_LIST *list;

  int i, saw_quote;
  char *ret;





  while (string[i])
    {

	break;



    }


    {
      list = (*func) (string, quoted);

	{
	  ret = string_list (list);

	}


    }






}

























char *
expand_string_to_string (string, quoted)
     char *string;

{

}

char *
expand_string_unsplit_to_string (string, quoted)
     char *string;

{

}

char *
expand_assignment_string_to_string (string, quoted)
     char *string;

{

}

char *
expand_arith_string (string, quoted)
     char *string;

{
  return (expand_string_if_necessary (string, quoted, expand_string));
}

#if defined (COND_COMMAND)

char *
remove_backslashes (string)
     char *string;
{













}









char *
cond_expand_word (w, special)
     WORD_DESC *w;

{































}
#endif





call_expand_word_internal (w, q, i, c, e)
     WORD_DESC *w;

{
  WORD_LIST *result;

  result = expand_word_internal (w, q, i, c, e);













}




expand_string_internal (string, quoted)
     char *string;

{
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);


  td.word = savestring (string);

  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);



}






WORD_LIST *
expand_string_unsplit (string, quoted)
     char *string;

{



















}


WORD_LIST *
expand_string_assignment (string, quoted)
     char *string;

{
  WORD_DESC td;
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);




  td.word = savestring (string);
  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);














}






WORD_LIST *
expand_prompt_string (string, quoted, wflags)
     char *string;


{





























}







expand_string_leave_quoted (string, quoted)
     char *string;

{
  WORD_LIST *tlist;


  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  tlist = expand_string_internal (string, quoted);








}

























WORD_LIST *
expand_string (string, quoted)
     char *string;

{
  WORD_LIST *result;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  result = expand_string_leave_quoted (string, quoted);

}






















char *
quote_escapes (string)
     char *string;
{

























}




























char *
dequote_escapes (string)
     char *string;
{
































}




























char *
quote_string (string)
     char *string;
{



























}


char *
dequote_string (string)
     char *string;
{



































}






















WORD_LIST *
dequote_list (list)
     WORD_LIST *list;
{












}



char *
remove_quoted_escapes (string)
     char *string;
{










}






char *
remove_quoted_nulls (string)
     char *string;
{





































}




word_list_remove_quoted_nulls (list)

{





























































































































}





















































































































































































































































































































































































































































































































































































































































































































































WORD_LIST *
expand_word (word, quoted)
     WORD_DESC *word;

{






}




WORD_LIST *
expand_word_unsplit (word, quoted)
     WORD_DESC *word;

{













}




WORD_LIST *
expand_word_leave_quoted (word, quoted)
     WORD_DESC *word;

{














}

#if defined (PROCESS_SUBSTITUTION)







#if !defined (HAVE_DEV_FD)















































































































































#else /* HAVE_DEV_FD */









char *
copy_fifo_list (sizep)
     int *sizep;
{



    {


      return (char *)NULL;
    }




























}


fifos_pending ()
{

}


num_fifos ()
{













}


unlink_fifo_list ()
{









}







close_new_fifos (list, lsize)


{














}


































#endif /* HAVE_DEV_FD */
























































































































































































#endif /* PROCESS_SUBSTITUTION */




















































































































WORD_DESC *
command_substitute (string, quoted)
     char *string;

{








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}



















































































































































char *
pat_subst (string, pat, rep, mflags)
     char *string, *pat, *rep;

{































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}





param_expand (string, sindex, quoted, expanded_something,
	      contains_dollar_at, quoted_dollar_at_p, had_quoted_null_p,
	      pflags)
     char *string;
     int *sindex, quoted, *expanded_something, *contains_dollar_at;

{
  char *temp, *temp1, uerror[3];
  int zindex, t_index, expok;
  unsigned char c;
  intmax_t number;
  SHELL_VAR *var;

  WORD_DESC *tdesc, *ret;


  zindex = *sindex;
  c = string[++zindex];






  switch (c)
    {








































































































































































































































    case LPAREN:

      t_index = zindex + 1;
      temp = extract_command_subst (string, &t_index, 0);
      zindex = t_index;




	{
	  char *temp2;
	  temp1 = temp + 1;
	  temp2 = savestring (temp1);
	  t_index = strlen (temp2) - 1;








	  temp2[t_index] = '\0';











	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);





	  number = evalexp (temp1, &expok);












	  temp = itos (number);
	  break;
	}




































    default:



      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)
	;
      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;














      var = find_variable (temp1);


	{














	    {
	      temp = value_cell (var);




	    }



	  goto return0;
	}




















    }


    zindex++;

return0:
  *sindex = zindex;


    {
      ret = alloc_word_desc ();

      ret->word = temp;
    }
  return ret;
}



























static WORD_LIST *
expand_word_internal (word, quoted, isexp, contains_dollar_at, expanded_something)
     WORD_DESC *word;

     int *contains_dollar_at;
     int *expanded_something;
{
  WORD_LIST *list;
  WORD_DESC *tword;


  char *istring;


  int istring_size;


  int istring_index;


  char *temp, *temp1;


  register char *string;


  size_t string_size;


  int sindex;


  int quoted_dollar_at;







  int had_quoted_null;
  int has_dollar_at;

  int pflags;			/* flags passed to param_expand */



  register unsigned char c;	/* Current character. */




  DECLARE_MBSTATE;

  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
  istring[istring_index = 0] = '\0';
  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;


  string = word->word;






  if (contains_dollar_at)
    *contains_dollar_at = 0;





  for (sindex = 0; ;)
    {
      c = string[sindex];


      switch (c)
	{
	case '\0':
	  goto finished_with_string;





















add_string:

	    {
	      istring = sub_append_string (temp, istring, &istring_index, &istring_size);

	    }

	  break;



































































































































	case '$':







	  tword = param_expand (string, &sindex, quoted, expanded_something,

			       &had_quoted_null, pflags);














	  temp = tword->word;


	  goto add_string;


























































































	case '"':
#if 0

#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;


	  temp = string_extract_double_quoted (string, &sindex, 0);




























































































































	    continue;

	add_quoted_string:


	    {



	      goto add_string;







	    }



	case '\'':
#if 0

#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;


	  temp = string_extract_single_quoted (string, &sindex);





























	    goto add_quoted_string;



	default:



	    {

		sindex++;

		{





#if HANDLE_MULTIBYTE

		    sindex--;






#endif





		}
	    }

	  SADD_MBCHAR (temp, string, sindex, string_size);

	add_character:


	  istring[istring_index++] = c;




	}
    }

finished_with_string:



























    {















































      char *ifs_chars;









      if (has_dollar_at && ifs_chars)
	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);

	{
	  tword = make_bare_word (istring);












	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
    }



}









char *
string_quote_removal (string, quoted)
     char *string;

{



























































































































































}

char *
getifs ()
{

}




WORD_LIST *
word_split (w, ifs_chars)
     WORD_DESC *w;
     char *ifs_chars;
{




































}



































separate_out_assignments (tlist)

{
  register WORD_LIST *vp, *lp;







  subst_assign_varlist = (WORD_LIST *)NULL;
  vp = lp = tlist;







  while (lp && (lp->word->flags & W_ASSIGNMENT))
    {

      lp = lp->next;







      subst_assign_varlist = tlist;


      tlist = lp;			/* remainder of word list */

















































    }
  return (tlist);
}

#define WEXP_VARASSIGN	0x001
#define WEXP_BRACEEXP	0x002
#define WEXP_TILDEEXP	0x004
#define WEXP_PARAMEXP	0x008
#define WEXP_PATHEXP	0x010



#define WEXP_ALL	(WEXP_VARASSIGN|WEXP_BRACEEXP|WEXP_TILDEEXP|WEXP_PARAMEXP|WEXP_PATHEXP)














WORD_LIST *
expand_words (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_ALL));
}



WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{

}

WORD_LIST *
expand_words_shellexp (list)
     WORD_LIST *list;








{




































































































}



























































































shell_expand_word_list (tlist, eflags)
     WORD_LIST *tlist;

{
  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list;
  int expanded_something, has_dollar_at;



  new_list = (WORD_LIST *)NULL;
  for (orig_list = tlist; tlist; tlist = next)
    {


      next = tlist->next;






























      expanded = expand_word_internal
	(tlist->word, 0, 0, &has_dollar_at, &expanded_something);




































      new_list = (WORD_LIST *)list_append (expanded, new_list);
    }





    new_list = REVERSE_LIST (new_list, WORD_LIST *);


}












static WORD_LIST *
expand_word_list_internal (list, eflags)
     WORD_LIST *list;

{
  WORD_LIST *new_list, *temp_list;
  int tint;

  if (list == 0)
    return ((WORD_LIST *)NULL);

  garglist = new_list = copy_word_list (list);

    {
      garglist = new_list = separate_out_assignments (new_list);

	{

	    {


	      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
		{

		  tint = do_word_assignment (temp_list->word, 0);










		}


	    }

	}
    }














  new_list = shell_expand_word_list (new_list, eflags);

































































}
